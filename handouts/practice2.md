# Practice2 ASTの生成1 定数と変数

ここからパーサーを本格的に実装していきましょう！

パーサーの役目は、Swiftのソースコードを読み取って、AST(Abstract Syntax Tree)に変換することです。

ソースコードをASTの形で保持しておき、後ほどそこからLLVM IRを生成していきます。
MinSwiftでは、定数、変数や関数宣言などを扱うことができます。

## Node

MinSwiftでは、全てのASTは以下のプロトコルに適合しています。

```swift
protocol Node { }
```

`Node`は全てのASTの基底となるプロトコルですが、何も宣言を持ちません。

今回利用するノードは、`ASTNode.swift`に全て予め用意しておきました。

## 2-1. `integerLiteral`のパース

まず非常に単純なただの数値リテラルをASTに変換してみましょう。

MinSwiftでは、`42`のような数値表現は`NumberNode`として表現されます。

`parseNumber`メソッドは、現在のカーソルから数値を読み取り、`NumberNode`として返却します。

今回実装する`parse~`メソッドは全て、呼び出されるときにそのノードがパースできるカーソル位置にあることを期待しています。
また、読み取りが終わった後は`read()`を行い、読み終わったトークンを全て消費します。

サンプルのために実装を用意しておきました。
`extractNumberLiteral`を実装してみてください。

## 2-2. `floatingLiteral`のパース

なにか説明することはありますか？

## 2-3. `identifier`のパース

今度は変数の呼び出しを`VariableNode`で表現します。

今のところ、何か`identifier`が現れたら変数呼び出しとして扱うことにしてしまいます。
`parseIdentifierExpression`を実装してみましょう。

悩ましいことに、SwiftSyntaxの世界では`identifier`は至る所に登場します。
変数、関数宣言、関数呼び出し、引数、ラベル、型など、ぜーんぶ`identifier`です

そのため、`parseIdentifierExpression`は、今後の実装が進むごとに変更が発生します。
以前までのテストケースを壊さないようにしましょう。

## まとめ

まだまだ簡単ですか？

実は今回の実装では負数を扱うことができません。
Swiftでは、`-`は`prefixOperator`として扱われるからです。

さらなるエッジケースとしては、Swiftでは`_`区切りの数字リテラルも扱えます。（`1_000`など)
そうです。Swiftの世界すべてを表現するにはあまりにも時間が足りないのです。

このような考慮漏れは今後も頻出しますが、考えないことにしてください。お腹が空いちゃいますよ！

